#!/usr/bin/env bash

set -e
set -u

OPTSTR="CRSbcdhlmrtu"

# Declare the variable keys here in the order of their dependecies
# This must be done here, since associative arrays do not guarantee that
# the keys are iterated in the order they are declared in the script
VARIABLES=(
        VMNAME WORKDIR ISOFILE CKPFILE GUESTIMG_DISK TMPFSDIR GUESTIMG_TMP
        GUESTIMG_SIZE MNTDIR MDNUM
)

declare -A DEFAULTS
set_vars() {
    CRTSCRIPT="$0"
    CRTSCRIPT_ABS="`readlink -f ${CRTSCRIPT}`"
    SCRIPTSDIR="${CRTSCRIPT_ABS%/*}"

    # Default values for variables in script-expandable format. Will be evaluated
    # when assigning the values to the variables
    DEFAULTS=(
        [VMNAME]='vmachine'
        [WORKDIR]='${SCRIPTSDIR}/${GUEST_TYPE}'
        [ISOFILE]='${WORKDIR}/disk.iso'
        [CKPFILE]='${WORKDIR}/test.ckp'
        [GUESTIMG_DISK]='${WORKDIR}/guest.img'
        [TMPFSDIR]='${SCRIPTSDIR}/tmpfs_dir' # This directory should be common between guests
        [GUESTIMG_TMP]='${TMPFSDIR}/${DEFAULTS[GUESTIMG_DISK]##*/}'
        [GUESTIMG_SIZE]='4096M'
        [MNTDIR]='/mnt'
        [MDNUM]='50' # big numbers have a small chance to be used # TODO: parse number if possible
    )

    for VAR in "${VARIABLES[@]}"; do
        eval ${VAR}="${!VAR:-${DEFAULTS[${VAR}]}}"
    done
}

longest_var_name() {
    local LEN=0

    for VAR in "${VARIABLES[@]}"; do
        if [ ${LEN} -lt ${#VAR} ]; then LEN=${#VAR}; fi
    done

    echo $((${LEN} + 1))
}

usage() {
    ALIGN_LEN=$(longest_var_name)

    eval 1>&2
    printf -- "$CRTSCRIPT [-CRSbcdhlmrtu]\n"
    printf -- "Perform regular operations on a bhyve virtual machine\n"
    printf -- "If a temp file exists, use it since it is in a tmpfs ramdisk\n"
    printf -- "since the image may get broken. To replace it, simply run \`$CRTSCRIPT -t\`\n"
    printf -- "If the tmpfs does not exist, the script create it and copy the image there to keep the disk image fresh\n"
    printf -- "\n"
    printf -- "At least one parameter must be provided.\n"
    printf -- "'-l' is a modifier - at least another parameter is required\n"
    printf -- "\n"
    printf -- "The following options are available:\n"
    printf -- "-C Create a checkpoint for the virtual machine\n"
    printf -- "-R Restore the virtual machine from a previous checkpoint\n"
    printf -- "-S Suspend the virtual machine\n"
    printf -- "-c Create a virtual machine named vmachine\n"
    printf -- "-d Destroy the virtual machine\n"
    printf -- "-h Display this help message and exit\n"
    printf -- "-l use a Linux guest in stead of FreeBSD. Must be the first argument if given\n"
    printf -- "-m create a memdisk device for the guest image and mount it over \$MNTDIR\n"
    printf -- "-r Run virtual machine\n"
    printf -- "-t copy virtual machine disk file to tmpfs\n"
    printf -- "-u unmount \$MNTDIR and delete the memdisk device\n"
    printf -- "\n"
    printf -- "The script uses the following variables:\n"
    printf -- " -- VMNAME:        Name of the virtual machine\n"
    printf -- " -- WORKDIR:       Root work directory for the guest type\n"
    printf -- " -- ISOFILE:       Name of the guest installation disk\n"
    printf -- " -- CKPFILE:       Name of guest memory checkpoint file\n"
    printf -- " -- GUESTIMG_DISK: Name of the guest image disk file\n"
    printf -- " -- TMPFSDIR:      A directory where the guest image will be copied; a tmpfs will be mounted on top of it\n"
    printf -- " -- GUESTIMG_TMP:  Name of the temporary copy of the guest disk file\n"
    printf -- " -- GUESTIMG_SIZE: Size of the guest image file, as used by truncate(1)\n"
    printf -- " -- MNTDIR:        Guest image mount target directory\n"
    printf -- "\n"
    printf -- "Default values:\n"
    for VAR in "${VARIABLES[@]}"; do
        printf " -> %-*s %s (%s)\n" ${ALIGN_LEN} "${VAR}:" "${DEFAULTS[${VAR}]}" "${!VAR}"
    done
    exit $1
}

GUEST_TYPE="freebsd"

while getopts "${OPTSTR}" opt; do
    case "${opt}" in
        l) GUEST_TYPE="linux";;
        h) usage 0;;
        *) ;;
    esac
done
# Allow another pass of the arguments later
OPTIND=1

set_vars

if [ $# -lt 1 ] || [ $# -eq 1 -a "$1" == "-l" ]; then usage 1; fi

GUESTIMG() {
    mkdir -p "${TMPFSDIR}"
    if ! $(mount | grep "`readlink -f ${TMPFSDIR}`" 2>&1 >/dev/null && test -f "${GUESTIMG_TMP}"); then
        cp_vm_tmpfs
    fi
    echo "${GUESTIMG_TMP}"
}

checkpoint_vm() {
    ${WORKDIR}/checkpoint_vm.sh "${CKPFILE}" "${VMNAME}"
}

restore_vm() {
    ${WORKDIR}/restore_vm.sh "$(GUESTIMG)" "${CKPFILE}" "${VMNAME}"
}

suspend_vm() {
    ${WORKDIR}/suspend_vm.sh "${CKPFILE}" "${VMNAME}"
}

cp_vm_tmpfs() {
    echo "Copying the virtual machine disk to tmpfs..." 1>&2
    if ! $(mount | grep "`readlink -f ${TMPFSDIR}`" 2>&1 >/dev/null); then
        mount -t tmpfs tmpfs "${TMPFSDIR}"
    fi

    rm -f -v "${TMPFSDIR}"/* 1>&2

    cp -v "${GUESTIMG_DISK}" "${GUESTIMG_TMP}"
} 1>&2

create_vm() {
    truncate -s ${GUESTIMG_SIZE} "${GUESTIMG_DISK}"
    ${WORKDIR}/create_vm.sh "${GUESTIMG_DISK}" "${ISOFILE}" "${VMNAME}" >/dev/null
    cp_vm_tmpfs
}

destroy_vm() {
    bhyvectl --destroy --vm="${VMNAME}"
}

run_vm() {
    ${WORKDIR}/run_vm.sh "$(GUESTIMG)" "${VMNAME}"
}

bad_argument() {
    echo "$@" 1>&2
    exit 3
}

mount_vm_image() {
    mdconfig -u "${MDNUM}" "$(GUESTIMG)"
    mount "/dev/md${MDNUM}s1a" "${MNTDIR}"
}

umount_vm_image() {
    umount "${MNTDIR}"
    mdconfig -d -u "${MDNUM}"
}

while getopts "${OPTSTR}" opt; do
    case "${opt}" in
        C) checkpoint_vm;;
        R) restore_vm;;
        S) suspend_vm;;
        c) create_vm;;
        d) destroy_vm;;
        h) ;;
        l) ;;
        m) mount_vm_image;;
        r) run_vm;;
        t) cp_vm_tmpfs;;
        u) umount_vm_image;;
        *) usage 1;;
    esac
done
